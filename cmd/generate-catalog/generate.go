package main

import (
	"encoding/base64"
	"fmt"
	"log"
	"os"
	"slices"

	semver "github.com/Masterminds/semver/v3"
	"github.com/goccy/go-yaml"
	container "github.com/google/go-containerregistry/pkg/name"
)

const (
	inputFile                       = "bundles.yaml"
	outputFile                      = "catalog-template.yaml"
	iconFile                        = "icon.png"
	channelDeprecationMessage       = "This version is no longer supported. Switch to the `stable` channel or a channel for a more recent version that is still supported. Find supported versions in the RHACS support policy document: https://access.redhat.com/support/policy/updates/rhacs"
	bundleDeprecationMessage        = "This Operator version is no longer supported. Use a more recent version that is supported. Find supported versions in the RHACS support policy document: https://access.redhat.com/support/policy/updates/rhacs"
	versionBrokenMessage            = "This product version has known significant defects and should not be used. Use a more recent version that is supported. Find supported versions in the RHACS support policy document: https://access.redhat.com/support/policy/updates/rhacs"
	latestChannelDeprecationMessage = "The `latest` channel is no longer supported. Use the `stable` channel."
	rhacsOperator                   = "rhacs-operator"
	olmTemplateSchema               = "olm.template.basic"
	olmPackageSchema                = "olm.package"
	olmChannelSchema                = "olm.channel"
	olmDeprecationsSchema           = "olm.deprecations"
	olmBundleSchema                 = "olm.bundle"
	latestChannelName               = "latest"
	stableChannelName               = "stable"
	first3MajorVersion              = "3.62.0"
	first4MajorVersion              = "4.0.0"
	brokenVersionSkippingOffset     = 2 // The number of versions to skip in the `skips` field of the channel entry for broken versions.
)

var headComment = []string{
	"--------------------------------------------------------------------------------",
	" DO NOT EDIT. This file is generated by cmd/generate-catalog/generate.go script.",
	" Any manual changes will be overwritten.",
	"--------------------------------------------------------------------------------",
}

func main() {
	err := generateCatalogTemplateFile()
	if err != nil {
		log.Fatalf("Failed to generate catalog template: %v", err)
	}
}

// generateCatalogTemplateFile reads the bundles.yaml file, processes the data, and writes the catalog template to the output file.
func generateCatalogTemplateFile() error {
	config, err := readInputFile(inputFile)
	if err != nil {
		return fmt.Errorf("failed to read bundle list file: %v", err)
	}

	pkg, err := generatePackageWithIcon()
	if err != nil {
		return fmt.Errorf("failed to generate package object with icon: %v", err)
	}
	channels := generateChannels(config.Versions)
	entries := generateChannelEntries(config.Versions, config.BrokenVersions)
	populateChannelEntries(channels, entries)

	deprecations := generateDeprecations(config.Versions, channels, config.OldestSupportedVersion, config.BrokenVersions)
	bundles := generateBundles(config.Images)

	ct := newCatalogTemplate()
	ct.addPackage(pkg)
	ct.addChannels(channels)
	ct.addDeprecations(deprecations)
	ct.addBundles(bundles)

	err = writeToFile(outputFile, ct)
	if err != nil {
		return fmt.Errorf("failed to write catalog template to file: %v", err)
	}

	fmt.Printf("%s generated successfully.\n", outputFile)

	return nil
}

// readInputFile reads YAML file into Configuration structure.
func readInputFile(filename string) (Configuration, error) {
	inputBytes, err := os.ReadFile(filename)
	if err != nil {
		return Configuration{}, fmt.Errorf("failed to read %s: %v", filename, err)
	}
	var input Input
	if err = yaml.Unmarshal(inputBytes, &input); err != nil {
		return Configuration{}, fmt.Errorf("failed to unmarshal YAML: %v", err)
	}

	oldest, err := semver.StrictNewVersion(input.OldestSupportedVersion)
	if err != nil {
		return Configuration{}, fmt.Errorf("invalid oldest_supported_version %q: %v", input.OldestSupportedVersion, err)
	}

	brokens := make(map[*semver.Version]bool, len(input.BrokenVersions))
	for _, s := range input.BrokenVersions {
		v, err := semver.StrictNewVersion(s)
		if err != nil {
			return Configuration{}, fmt.Errorf("invalid item in broken_versions %q: %v", s, err)
		}
		brokens[v] = true
	}

	var images []BundleImage
	for _, img := range input.Images {
		v, err := semver.StrictNewVersion(img.Version)
		if err != nil {
			return Configuration{}, fmt.Errorf("invalid version %q for image %q: %v", img.Version, img.Image, err)
		}
		images = append(images, BundleImage{
			Image:   img.Image,
			Version: v,
		})
	}

	// TODO: ROX-30604 check that image reference is associated with the provided version.
	if err = validateImageReferences(images); err != nil {
		return Configuration{}, err
	}

	versions := getAllVersions(images)
	if err = validateVersionsAreSorted(versions); err != nil {
		return Configuration{}, err
	}
	if err = hasGapInVersions(versions); err != nil {
		return Configuration{}, err
	}
	if err = validateBrokenVersions(brokens, versions); err != nil {
		return Configuration{}, err
	}
	if !slices.ContainsFunc(versions, oldest.Equal) {
		return Configuration{}, fmt.Errorf("oldest supported version %s is not present in the list of versions", oldest)
	}

	return Configuration{
		OldestSupportedVersion: oldest,
		BrokenVersions:         brokens,
		Images:                 images,
		Versions:               versions,
	}, nil
}

// generatePackageWithIcon creates a new "olm.package" object with an operator icon.
func generatePackageWithIcon() (Package, error) {
	data, err := os.ReadFile(iconFile)
	if err != nil {
		return Package{}, fmt.Errorf("failed to read %s: %v", iconFile, err)
	}
	iconBase64 := base64.StdEncoding.EncodeToString(data)
	pkg := newPackage(stableChannelName, iconBase64)

	return pkg, nil
}

func generateChannels(versions []*semver.Version) []Channel {
	channels := make([]Channel, 0)

	for _, v := range versions {
		// latest channel is historically placed between rhacs-3.y and rhacs-4.y channels.
		if v.String() == first4MajorVersion {
			latestChannel := newLatestChannel()
			channels = append(channels, latestChannel)
		}
		yStream := makeYStreamVersion(v)
		if len(channels) == 0 || !yStream.Equal(channels[len(channels)-1].yStreamVersion) {
			// Create a new channel for each new Y-Stream
			channel := newChannel(yStream)
			channels = append(channels, channel)
		}
	}
	// Create a stable channel at the end
	stableChannel := newStableChannel()
	channels = append(channels, stableChannel)

	return channels
}

func generateChannelEntries(versions []*semver.Version, skippedVersions map[*semver.Version]bool) []ChannelEntry {
	channelEntries := make([]ChannelEntry, 0)
	// We know that our catalog begins with 3.62.0. We set previousEntryVersion to 3.61.0 in order to have 3.62.0's `skipRange` consistent with others.
	previousEntryVersion := semver.New(3, 61, 0, "", "")
	var previousYStreamVersion *semver.Version

	for _, v := range versions {
		if v.Minor() != previousEntryVersion.Minor() {
			previousYStreamVersion = makeYStreamVersion(previousEntryVersion)
		}

		e := newChannelEntry(v, previousEntryVersion, previousYStreamVersion, skippedVersions)
		channelEntries = append(channelEntries, e)

		previousEntryVersion = v
	}

	return channelEntries
}

func populateChannelEntries(channels []Channel, channelEntries []ChannelEntry) {
	for i, channel := range channels {
		for _, entry := range channelEntries {
			if channelShouldHaveEntry(channel, entry) {
				channels[i].Entries = append(channels[i].Entries, entry)
			}
		}
	}
}

func channelShouldHaveEntry(channel Channel, entry ChannelEntry) bool {
	validForLatest := channel.Name == latestChannelName && entry.version.Major() < 4
	validForStable := channel.Name == stableChannelName && entry.version.Major() >= 4
	validForVersioned := channel.yStreamVersion != nil &&
		entry.version.Major() == channel.yStreamVersion.Major() &&
		entry.version.Minor() <= channel.yStreamVersion.Minor()
	return validForLatest || validForStable || validForVersioned
}

// generateDeprecations creates an object with a list of deprecations based on the provided versions.
func generateDeprecations(versions []*semver.Version, channels []Channel, oldestSupportedVersion *semver.Version, brokenVersions map[*semver.Version]bool) Deprecations {
	var deprecations []DeprecationEntry

	latestChannelDeprecationEntry := newChannelDeprecationEntry(latestChannelName, latestChannelDeprecationMessage)
	deprecations = append(deprecations, latestChannelDeprecationEntry)

	for _, channel := range channels {
		if channel.yStreamVersion != nil && channel.yStreamVersion.LessThan(oldestSupportedVersion) {
			channelDeprecation := newChannelDeprecationEntry(channel.Name, channelDeprecationMessage)
			deprecations = append(deprecations, channelDeprecation)
		}
	}

	// deprecate all bundles that are older than the oldest supported version
	for _, v := range versions {
		msg := ""
		if v.LessThan(oldestSupportedVersion) {
			msg = bundleDeprecationMessage
		}
		if brokenVersions[v] {
			msg = versionBrokenMessage
		}
		if msg != "" {
			deprecations = append(deprecations, newBundleDeprecationEntry(v, msg))
		}
	}

	return newDeprecations(deprecations)
}

// generateBundles creates a list of bundle entries based on their corresponding images.
func generateBundles(images []BundleImage) []BundleEntry {
	var bundleEntries []BundleEntry
	for _, img := range images {
		bundleEntries = append(bundleEntries, newBundleEntry(img.Image))
	}
	return bundleEntries
}

// writeToFile writes the resulting catalog template to the output YAML file.
func writeToFile(filename string, ct CatalogTemplate) error {
	comment := yaml.HeadComment(headComment...)
	comments := yaml.CommentMap{
		"$": []*yaml.Comment{comment}, // "$" means top-level comment
	}

	out, err := yaml.MarshalWithOptions(ct, yaml.WithComment(comments))
	if err != nil {
		return fmt.Errorf("failed to marshal catalog template: %v", err)
	}
	if err := os.WriteFile(filename, out, 0644); err != nil {
		return fmt.Errorf("failed to write output: %v", err)
	}

	return nil
}

// validateVersionsAreSorted checks that the operator versions are sorted in ascending order and that there are no duplicates.
// The sorted order is important for the correct functioning of the rest of the program.
func validateVersionsAreSorted(versions []*semver.Version) error {
	for i := 0; i < len(versions)-1; i++ {
		currentVersion := versions[i]
		nextVersion := versions[i+1]
		if currentVersion.GreaterThanEqual(nextVersion) {
			return fmt.Errorf("versions are not sorted in ascending order: %s is not less than %s", currentVersion, nextVersion)
		}
	}
	return nil
}

func hasGapInVersions(versions []*semver.Version) error {
	for i := 0; i < len(versions)-1; i++ {
		var expectedNextVersion *semver.Version
		currentVersion := versions[i]
		nextVersion := versions[i+1]

		if currentVersion.Major() != nextVersion.Major() {
			expectedNextVersion = semver.New(currentVersion.Major()+1, 0, 0, "", "")
		}
		if currentVersion.Major() == nextVersion.Major() && currentVersion.Minor() != nextVersion.Minor() {
			expectedNextVersion = semver.New(currentVersion.Major(), currentVersion.Minor()+1, 0, "", "")
		}
		if currentVersion.Major() == nextVersion.Major() && currentVersion.Minor() == nextVersion.Minor() {
			expectedNextVersion = semver.New(currentVersion.Major(), currentVersion.Minor(), currentVersion.Patch()+1, "", "")
		}

		if expectedNextVersion.Major() != nextVersion.Major() || expectedNextVersion.Minor() != nextVersion.Minor() || expectedNextVersion.Patch() != nextVersion.Patch() {
			return fmt.Errorf("unexpected version sequence [%s, %s]: %s should be followed by %s", currentVersion, nextVersion, currentVersion, expectedNextVersion)
		}
	}

	return nil
}

func validateBrokenVersions(brokenVersions map[*semver.Version]bool, versions []*semver.Version) error {
	for brokenVersion := range brokenVersions {
		if !slices.ContainsFunc(versions, brokenVersion.Equal) {
			return fmt.Errorf("broken version %s is not present in the list of versions", brokenVersion)
		}
	}
	return nil
}

// validateImageReferences checks that all images in the input bundle have valid container image references with a digest.
func validateImageReferences(images []BundleImage) error {
	for _, img := range images {
		if err := validateImageReference(img.Image); err != nil {
			return err
		}
	}
	return nil
}

func validateImageReference(imageRef string) error {
	// Use NewDigest with StrictValidation to ensure the reference includes a digest, repository and registry.
	_, err := container.NewDigest(imageRef, container.StrictValidation)
	if err != nil {
		return fmt.Errorf("cannot parse string as container image reference: %w", err)
	}
	return nil
}
