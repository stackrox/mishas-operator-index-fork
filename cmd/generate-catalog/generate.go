package main

import (
	// needed for digest algorithm validation
	_ "crypto/sha256"

	"encoding/base64"
	"fmt"
	"log"
	"maps"
	"os"
	"slices"

	semver "github.com/Masterminds/semver/v3"
	"github.com/distribution/reference"
	"github.com/goccy/go-yaml"
)

const (
	inputFile                       = "bundles.yaml"
	outputFile                      = "catalog-template.yaml"
	iconFile                        = "icon.png"
	channelDeprecationMessage       = "This version is no longer supported. Switch to the `stable` channel or a channel for a more recent version that is still supported. Find supported versions in the RHACS support policy document: https://access.redhat.com/support/policy/updates/rhacs"
	bundleDeprecationMessage        = "This Operator version is no longer supported. Use a more recent version that is supported. Find supported versions in the RHACS support policy document: https://access.redhat.com/support/policy/updates/rhacs"
	versionBrokenMessage            = "This product version has known significant defects and should not be used. Use a more recent version that is supported. Find supported versions in the RHACS support policy document: https://access.redhat.com/support/policy/updates/rhacs"
	latestChannelDeprecationMessage = "The `latest` channel is no longer supported. Use the `stable` channel."
	latestChannelName               = "latest"
	stableChannelName               = "stable"
	first3MajorVersion              = "3.62.0"
	first4MajorVersion              = "4.0.0"
	resultYamlHeadComment           = `--------------------------------------------------------------------------------
# DO NOT EDIT. This file is generated by cmd/generate-catalog/generate.go script.
# Any manual changes will be overwritten.
#--------------------------------------------------------------------------------`
)

func main() {
	err := generateCatalogTemplateFile()
	if err != nil {
		log.Fatalf("Failed to generate catalog template: %v", err)
	}
}

// generateCatalogTemplateFile reads the bundles.yaml file, processes the data, and writes the catalog template to the output file.
func generateCatalogTemplateFile() error {
	config, err := readInputFile(inputFile)
	if err != nil {
		return fmt.Errorf("failed to read bundle list file: %v", err)
	}
	versions := getAllVersions(config.Images)
	skippedVersions := slices.Collect(maps.Keys(config.BrokenVersions))

	pkg, err := generatePackageWithIcon()
	if err != nil {
		return fmt.Errorf("failed to generate package object with icon: %v", err)
	}
	channels := generateChannels(versions)
	entries := generateChannelEntries(versions, skippedVersions)
	channels, err = addChannelEntries(channels, entries)
	if err != nil {
		return fmt.Errorf("failed to add channel entries: %v", err)
	}

	deprecations := generateDeprecations(versions, channels, config.OldestSupportedVersion, config.BrokenVersions)
	bundles := generateBundles(config.Images)

	ct := newCatalogTemplate()
	ct.addPackage(pkg)
	ct.addChannels(channels)
	ct.addDeprecations(deprecations)
	ct.addBundles(bundles)

	err = writeToFile(outputFile, ct)
	if err != nil {
		return fmt.Errorf("failed to write catalog template to file: %v", err)
	}

	fmt.Printf("%s generated successfully.\n", outputFile)

	return nil
}

// readInputFile unmarshals YAML file onto Configuration structure.
func readInputFile(filename string) (Configuration, error) {
	inputBytes, err := os.ReadFile(filename)
	if err != nil {
		return Configuration{}, fmt.Errorf("failed to read %s: %v", filename, err)
	}
	var input Input
	if err := yaml.Unmarshal(inputBytes, &input); err != nil {
		return Configuration{}, fmt.Errorf("failed to unmarshal YAML: %v", err)
	}

	var config Configuration
	oldest, err := semver.NewVersion(input.OldestSupportedVersion)
	if err != nil {
		return Configuration{}, fmt.Errorf("invalid oldest_supported_version %q: %v", input.OldestSupportedVersion, err)
	}

	brokens := make(map[*semver.Version]bool)
	for _, s := range input.BrokenVersions {
		v, err := semver.NewVersion(s)
		if err != nil {
			return Configuration{}, fmt.Errorf("invalid broken_versions %q: %v", s, err)
		}
		brokens[v] = true
	}

	var images []BundleImage
	for _, img := range input.Images {
		v, err := semver.NewVersion(img.Version)
		if err != nil {
			return Configuration{}, fmt.Errorf("invalid version %q for image %q: %v", img.Version, img.Image, err)
		}
		images = append(images, BundleImage{
			Image:   img.Image,
			Version: v,
		})
	}
	config = Configuration{
		OldestSupportedVersion: oldest,
		BrokenVersions:         brokens,
		Images:                 images,
	}

	if err := validateImages(config.Images); err != nil {
		return Configuration{}, err
	}
	if err := validateVersions(config.Images); err != nil {
		return Configuration{}, err
	}

	return config, nil
}

// getAllVersions extracts all operator versions from the input images.
func getAllVersions(images []BundleImage) []*semver.Version {
	versions := make([]*semver.Version, 0, len(images))
	for _, img := range images {
		versions = append(versions, img.Version)
	}
	return versions
}

// generatePackageWithIcon creates a new "olm.package" object with an operator icon.
func generatePackageWithIcon() (Package, error) {
	data, err := os.ReadFile(iconFile)
	if err != nil {
		return Package{}, fmt.Errorf("failed to read %s: %v", iconFile, err)
	}
	iconBase64 := base64.StdEncoding.EncodeToString(data)

	packageWithIcon := Package{
		Schema:         "olm.package",
		Name:           "rhacs-operator",
		DefaultChannel: stableChannelName,
		Icon: Icon{
			Base64data: iconBase64,
			MediaType:  "image/png",
		},
	}

	return packageWithIcon, nil
}

func generateChannels(versions []*semver.Version) []Channel {
	channels := make([]Channel, 0)

	for _, v := range versions {
		if v.Original() == first4MajorVersion {
			latestChannel := newLatestChannel(nil)
			channels = append(channels, latestChannel)
		}
		if v.Patch() == 0 {
			// Create a new channel for each new minor version (patch = 0)
			channel := newChannel(v, nil)
			channels = append(channels, *channel)
		}

	}
	// Create a stable channel at the end
	stableChannel := newStableChannel(nil)
	channels = append(channels, stableChannel)

	return channels
}

func generateChannelEntries(versions []*semver.Version, skippedVersions []*semver.Version) []ChannelEntry {
	channelEntries := make([]ChannelEntry, 0)
	// very first version in the catalog replaces 3.61.0 and skipRanges starts from 3.61.0
	previousEntryVersion := semver.MustParse("3.61.0")
	previousChannelVersion := semver.MustParse("3.61.0")

	for _, v := range versions {
		if v.Minor() != previousEntryVersion.Minor() {
			previousChannelVersion = previousEntryVersion
		}

		catalogChannelEntry := newChannelEntry(v, previousEntryVersion, previousChannelVersion, skippedVersions)
		channelEntries = append(channelEntries, catalogChannelEntry)

		previousEntryVersion = v
	}

	return channelEntries
}

func addChannelEntries(channels []Channel, channelEntries []ChannelEntry) ([]Channel, error) {
	updateChannels := make([]Channel, 0, len(channels))

	entriesFrom := 0
	entriesUntil := 0
	for _, channel := range channels {
		if channel.FirstVersion == nil {
			// skip "stable" and "latest" channels without version
			continue
		}
		// iterate through all channel entries and find the entries that fits for the current channel
		for entriesUntil < len(channelEntries) &&
			channelEntries[entriesUntil].Version.Major() <= channel.FirstVersion.Major() &&
			channelEntries[entriesUntil].Version.Minor() <= channel.FirstVersion.Minor() {
			// Update the entriesFrom index when the first 4.x.x version is reached to ignore all 3.x.x versions.
			// There was a decision to not provide an upgrade path from 3.x.x to 4.x.x.
			// Thus 4.x channels should not contain any entries from 3.x.x versions.
			// Also add all 3.x.x channel entries to the "latest" channel.
			if channelEntries[entriesUntil].Version.Equal(semver.MustParse(first4MajorVersion)) {
				latestChannel, err := addChannelEntriesByName(channels, latestChannelName, channelEntries[entriesFrom:entriesUntil])
				if err != nil {
					return nil, fmt.Errorf("failed to add entries to latest channel: %v", err)
				}
				updateChannels = append(updateChannels, latestChannel)

				entriesFrom = entriesUntil
			}

			entriesUntil++
		}

		channel.Entries = channelEntries[entriesFrom:entriesUntil]
		updateChannels = append(updateChannels, channel)
	}
	stableChannel, err := addChannelEntriesByName(channels, stableChannelName, channelEntries[entriesFrom:entriesUntil])
	if err != nil {
		return nil, fmt.Errorf("failed to add entries to stable channel: %v", err)
	}
	updateChannels = append(updateChannels, stableChannel)

	return updateChannels, nil
}

func addChannelEntriesByName(channels []Channel, channelName string, channelEntries []ChannelEntry) (Channel, error) {
	for _, channel := range channels {
		if channel.Name == channelName {
			channel.Entries = append(channel.Entries, channelEntries...)
			return channel, nil
		}
	}
	return Channel{}, fmt.Errorf("channel with name %s not found", channelName)
}

// generateDeprecations creates an object with a list of deprecations based on the provided versions.
func generateDeprecations(versions []*semver.Version, channels []Channel, oldestSupportedVersion *semver.Version, brokenVersions map[*semver.Version]bool) Deprecations {
	var deprecations []DeprecationEntry

	for _, channel := range channels {
		if channel.FirstVersion != nil && channel.FirstVersion.LessThan(oldestSupportedVersion) {
			channelDeprecation := newChannelDeprecationEntry(channel.Name, channelDeprecationMessage)
			deprecations = append(deprecations, channelDeprecation)
		}
	}

	latestDeprecationEntry := newChannelDeprecationEntry(latestChannelName, latestChannelDeprecationMessage)
	deprecations = append(deprecations, latestDeprecationEntry)

	// deprecate all bundles that are older than the oldest supported version
	for _, v := range versions {
		if v.LessThan(oldestSupportedVersion) {
			deprecationMessage := bundleDeprecationMessage
			if brokenVersions[v] {
				deprecationMessage = versionBrokenMessage
			}
			deprecations = append(deprecations, newBundleDeprecationEntry(v, deprecationMessage))
		}
	}

	return newDeprecations(deprecations)
}

// generateBundles creates a list of bundle entries based on the provided versions and their corresponding images.
func generateBundles(images []BundleImage) []BundleEntry {
	var bundleEntries []BundleEntry
	for _, img := range images {
		bundleEntries = append(bundleEntries, newBundleEntry(img.Image))
	}
	return bundleEntries
}

// writeToFile writes the resulting catalog template to the output YAML file.
func writeToFile(filename string, ct CatalogTemplate) error {
	headComment := yaml.HeadComment(resultYamlHeadComment)
	comments := yaml.CommentMap{
		"$": []*yaml.Comment{headComment}, // "$" means top-level comment
	}

	out, err := yaml.MarshalWithOptions(ct, yaml.WithComment(comments))
	if err != nil {
		return fmt.Errorf("failed to marshal catalog: %v", err)
	}
	if err := os.WriteFile(filename, out, 0644); err != nil {
		return fmt.Errorf("failed to write output: %v", err)
	}

	return nil
}

// validateVersions checks that the operator versions are sorted in ascending order and that there are no duplicates.
func validateVersions(images []BundleImage) error {
	for i := 0; i < len(images)-1; i++ {
		version := images[i].Version
		nextVersion := images[i+1].Version
		if version == nil {
			return fmt.Errorf("version is not set for image %s", images[i].Image)
		}
		if nextVersion == nil {
			return fmt.Errorf("version is not set for image %s", images[i+1].Image)
		}
		if version.GreaterThanEqual(nextVersion) {
			return fmt.Errorf("operator versions are not sorted in ascending order: %s > %s", version.Original(), nextVersion.Original())
		}
	}
	return nil
}

// validateImages checks that all images in the input bundle have valid container image references with a digest.
func validateImages(images []BundleImage) error {
	for _, img := range images {
		if err := validateImageReference(img.Image); err != nil {
			return fmt.Errorf("invalid image reference %q: %w", img.Image, err)
		}
	}
	return nil
}

// validateImageReference validates that the provided image string is a valid container image reference with a digest
func validateImageReference(image string) error {
	// validate the image reference using the distribution/reference package
	ref, err := reference.Parse(image)
	if err != nil {
		return fmt.Errorf("cannot parse string as docker image %s: %w", image, err)
	}
	if _, ok := ref.(reference.Canonical); !ok {
		return fmt.Errorf("image reference does not include a digest")
	}
	return nil
}
