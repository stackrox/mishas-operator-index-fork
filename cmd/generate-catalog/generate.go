package main

import (
	// needed for digest algorithm validation
	_ "crypto/sha256"

	"encoding/base64"
	"fmt"
	"log"
	"os"
	"slices"

	semver "github.com/Masterminds/semver/v3"
	"github.com/distribution/reference"
	"github.com/goccy/go-yaml"
)

const (
	inputFile                       = "bundles.yaml"
	outputFile                      = "template/catalog-template.yaml"
	iconFile                        = "icon.png"
	firstLineHeadComment            = "DO NOT EDIT. This file is generated by cmd/generate-catalog/generate.go script."
	secondLineHeadComment           = "Any manual changes will be overwritten."
	channelDeprecationMessage       = "This version is no longer supported. Please switch to the `stable` channel or a channel for a version that is still supported.\n"
	bundleDeprecationMessage        = "This operator bundle version is no longer supported. Please switch to non deprecated bundle version for support.\n"
	deprecationMessageLatestChannel = "The `latest` channel is no longer supported.  Please switch to the `stable` channel.\n"
)

func main() {
	input, err := readInputFile()
	if err != nil {
		log.Fatalf("Failed to read bundle list file: %v", err)
	}

	versions := make([]*semver.Version, 0)
	for _, img := range input.Images {
		versions = append(versions, img.Version)
	}

	versionToImageMap, err := buildMapVersionToImage(input.Images)
	if err != nil {
		log.Fatalf("Failed to parse versions: %v", err)
	}

	pkg, err := generatePackageWithIcon()
	if err != nil {
		log.Fatalf("Failed to generate package object with icon: %v", err)
	}
	channels := generateChannels(versions, input.BrokenVersions)
	deprecations := generateDeprecations(versions, input.OldestSupportedVersion)
	bundles := generateBundles(versions, versionToImageMap)

	ct := newCatalogTemplate()
	ct.addPackage(pkg)
	ct.addChannels(channels)
	ct.addDeprecations(deprecations)
	ct.addBundles(bundles)

	err = ct.writeToFile()
	if err != nil {
		log.Fatalf("Failed to write catalog template to file: %v", err)
	}

	fmt.Printf("%s generated successfully.\n", outputFile)
}

// readInputFile unmarshals YAML file onto Input structure.
func readInputFile() (Input, error) {
	inputBytes, err := os.ReadFile(inputFile)
	if err != nil {
		return Input{}, fmt.Errorf("failed to read %s: %v", inputFile, err)
	}
	var input Input
	if err := yaml.Unmarshal(inputBytes, &input); err != nil {
		return Input{}, fmt.Errorf("failed to parse YAML: %v", err)
	}

	for i := 0; i < len(input.Images)-1; i++ {
		version := input.Images[i].Version
		nextVersion := input.Images[i+1].Version
		if version.GreaterThan(nextVersion) {
			return Input{}, fmt.Errorf("operator bundle images are not sorted in ascending order: %s > %s", version.Original(), nextVersion.Original())
		}
	}

	return input, nil
}

// buildMapVersionToImage returns a mapping from version to BundleImage.
func buildMapVersionToImage(images []BundleImage) (map[*semver.Version]BundleImage, error) {
	versionToImageMap := make(map[*semver.Version]BundleImage)

	for _, img := range images {
		err := validateImageReference(img.Image)
		if err != nil {
			return nil, fmt.Errorf("invalid image reference %q: %w", img.Image, err)
		}
		versionToImageMap[img.Version] = img
	}

	return versionToImageMap, nil
}

// generatePackageWithIcon creates a new "olm.package" object with an operator icon.
func generatePackageWithIcon() (Package, error) {
	data, err := os.ReadFile(iconFile)
	if err != nil {
		return Package{}, fmt.Errorf("failed to read icon.png: %v", err)
	}
	iconBase64 := base64.StdEncoding.EncodeToString(data)

	packageWithIcon := Package{
		Schema:         "olm.package",
		Name:           "rhacs-operator",
		DefaultChannel: "stable",
		Icon: Icon{
			Base64data: iconBase64,
			MediaType:  "image/png",
		},
	}

	return packageWithIcon, nil
}

// generateChannels creates a list of channels based on the provided bundle versions.
func generateChannels(versions []*semver.Version, brokenVersions []*semver.Version) []Channel {
	channels := make([]Channel, 0)
	// The list of ChannelEntry for specific major version (4.2 channel contains all <= 4.2.X versions starting from 4.0.0)
	majorEntries := make([]ChannelEntry, 0)
	// Very first version in the catalog replaces 3.61.0 and skipRanges starts from 3.61.0
	previousEntryVersion := semver.MustParse("3.61.0")
	previousChannelVersion := semver.MustParse("3.61.0")
	var channel *Channel

	for _, v := range versions {
		// Refresh major channel entries list when new major version is reached
		if v.Major() != previousEntryVersion.Major() {
			majorEntries = make([]ChannelEntry, 0)
		}

		// Create a new channel entry for each new minor version (patch = 0)
		if v.Patch() == 0 {
			previousChannelVersion = previousEntryVersion
			if channel != nil {
				channels = append(channels, *channel)
				// Add "latest" channel when all "3.X.X" version are processed
				if v.Original() == "4.0.0" {
					latestChannel := newLatestChannel(channel.Entries)
					channels = append(channels, latestChannel)
				}
			}
			channel = newChannel(v, slices.Clone(majorEntries))
		}

		catalogChannelEntry := newChannelEntry(v, previousEntryVersion, previousChannelVersion, brokenVersions)
		channel.Entries = append(channel.Entries, catalogChannelEntry)
		majorEntries = append(majorEntries, catalogChannelEntry)

		previousEntryVersion = v
	}

	// Add the last channel entry for the last version processed
	channels = append(channels, *channel)
	// Add "stable" channel when the last version is reached
	stableChannel := newStableChannel(channel.Entries)
	channels = append(channels, stableChannel)

	return channels
}

// generateDeprecations creates an object with a list of deprecations based on the provided versions.
func generateDeprecations(versions []*semver.Version, oldestSupportedVersion *semver.Version) Deprecations {
	var deprecations []DeprecationEntry
	var channelVersions []*semver.Version
	for _, v := range versions {
		// Each 0 Patch version indicates a new channel.
		if v.Patch() == 0 {
			channelVersions = append(channelVersions, v)
		}
	}

	// Deprecate all channels that are older than the oldest supported version
	for _, channelVersion := range channelVersions {
		if channelVersion.LessThan(oldestSupportedVersion) {
			deprecations = append(deprecations, newChannelDeprecationEntry(channelVersion))
		}
	}

	// Deprecate all bundles that are older than the oldest supported version
	for _, v := range versions {
		if v.LessThan(oldestSupportedVersion) {
			deprecations = append(deprecations, newBundleDeprecationEntry(v))
		}
	}

	return newDeprecation(deprecations)
}

// generateBundles creates a list of bundle entries based on the provided versions and their corresponding images.
func generateBundles(versions []*semver.Version, versionToImageMap map[*semver.Version]BundleImage) []BundleEntry {
	var bundleEntries []BundleEntry
	for _, v := range versions {
		bundleEntries = append(bundleEntries, newBundleEntry(versionToImageMap[v].Image))
	}
	return bundleEntries
}

func generateChannelName(version *semver.Version) string {
	return fmt.Sprintf("rhacs-%d.%d", version.Major(), version.Minor())
}

func generateBundleName(version *semver.Version) string {
	return fmt.Sprintf("rhacs-operator.v%d.%d.%d", version.Major(), version.Minor(), version.Patch())
}

// validateImageReference validates that the provided image string is a valid container image reference with a digest
func validateImageReference(image string) error {
	// Validate the image reference using the distribution/reference package
	ref, err := reference.Parse(image)
	if err != nil {
		return fmt.Errorf("cannot parse string as docker image %s: %w", image, err)
	}
	if _, ok := ref.(reference.Canonical); !ok {
		return fmt.Errorf("image reference does not include a digest")
	}
	return nil
}
